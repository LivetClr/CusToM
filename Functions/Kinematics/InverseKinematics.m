function [] = InverseKinematics(AnalysisParameters,varargin)
% Computation of the inverse kinematics step
%   Computation of joint coordinates from motion capture data and a
%   biomechanical model
%
%	Based on:
% 	- Lu, T. W., & Oï¿½connor, J. J. (1999). 
%	Bone position estimation from skin marker co-ordinates using global optimisation with joint constraints. Journal of biomechanics, 32(2), 129-134.
%
%   INPUT
%   - AnalysisParameters: parameters of the musculoskeletal analysis,
%   automatically generated by the graphic interface 'Analysis';
%   - varargin: if the function 'InverseKinematics' is used in a
%   calibration step, the variable 'BiomechanicalModel' is defined as an
%   input.
%   OUTPUT
%   Results are automatically saved on the folder associated to each motion
%   capture in variables 'ExperimentalData' and 'InverseKinematicsResults'.
%________________________________________________________
%
% Licence
% Toolbox distributed under GPL 3.0 Licence
%________________________________________________________
%
% Authors : Antoine Muller, Charles Pontonnier, Pierre Puchaud and
% Georges Dumont
%________________________________________________________

if numel(varargin)
    BiomechanicalModel = varargin{1};
else
    load('BiomechanicalModel.mat'); %#ok<LOAD>
end

% Inverse kinematics
for i = 1:numel(AnalysisParameters.filename)
    if isequal(AnalysisParameters.General.InputData, @MVNX_V3) % Load inverse kinematics from a MVNX
        MVNXInverseKinematics(AnalysisParameters.filename{i}(1:end-(numel(AnalysisParameters.General.Extension)-1)), AnalysisParameters);
    else
        filename = AnalysisParameters.filename{i}(1:end-(numel(AnalysisParameters.General.Extension)-1));
        if AnalysisParameters.IK.Method == 1
            
            [ExperimentalData, InverseKinematicsResults] =  InverseKinematicsOpti(filename,AnalysisParameters,BiomechanicalModel);

            
            save([filename '/ExperimentalData'],'ExperimentalData');
            save([filename '/InverseKinematicsResults_0'],'InverseKinematicsResults');
            sigma = 0.5e-2;
            tiragesx1 = randn(1,100)*sigma;
            tiragesx2 = randn(1,100)*sigma;
            tiragesx3 = randn(1,100)*sigma;
            tiragesy1 = randn(1,100)*sigma;
            tiragesy2 = randn(1,100)*sigma;
            tiragesy3 = randn(1,100)*sigma;
            
            Tirages.tiragesxTS = tiragesx1;
            Tirages.tiragesyTS = tiragesy1;           
            Tirages.tiragesxAA = tiragesx2;
            Tirages.tiragesyAA = tiragesy2;            
            Tirages.tiragesxAI = tiragesx3;
            Tirages.tiragesyAI = tiragesy3;
            
            cpt =1;
            
            for dx1 = tiragesx1
                for dx2 = tiragesx2
                    for dx3 = tiragesx3
                        for dy1 = tiragesy1
                            for dy2 = tiragesy2
                                for dy3 = tiragesy3
                                       Bruit.depfixe = [dx1 dy1 ; dx2 dy2 ; dx3 dy3];
                                        Bruit.sigma_suivi = 3e-2;
                                        [~, InverseKinematicsResults] =  InverseKinematicsOptiAjoutdeBruit(filename,AnalysisParameters,BiomechanicalModel,Bruit);
                                        InverseKinematicsResults.Bruit = Bruit;
                                        save([filename '/InverseKinematicsResults_' num2str(cpt)],'InverseKinematicsResults');
                                        cpt = cpt+1;
                                end
                            end
                        end
                    end
                end
            end
                                        
       elseif AnalysisParameters.IK.Method == 2
            [ExperimentalData, InverseKinematicsResults] = InverseKinematicsLM(filename,AnalysisParameters,BiomechanicalModel); % Levenberg-Marquardt algorithm
        end

        % Save data
    end
end

end